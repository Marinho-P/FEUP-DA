<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA Project 2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA Project 2
   </div>
   <div id="projectbrief">Routing Algorithm for Ocean Shipping and Urban Deliveries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class representing a graph.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa58172b1ae8602834b045659efd29c8" id="r_aaa58172b1ae8602834b045659efd29c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa58172b1ae8602834b045659efd29c8">Graph</a> (const string &amp;edge_file, const string &amp;vertex_file=&quot;&quot;)</td></tr>
<tr class="memdesc:aaa58172b1ae8602834b045659efd29c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="class_graph.html" title="Class representing a graph.">Graph</a> class.  <br /></td></tr>
<tr class="separator:aaa58172b1ae8602834b045659efd29c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c210a08b68a8b7c1e162662aa73f50" id="r_a61c210a08b68a8b7c1e162662aa73f50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61c210a08b68a8b7c1e162662aa73f50">read_edges</a> (const string &amp;edge_file, bool comesWithNodes)</td></tr>
<tr class="memdesc:a61c210a08b68a8b7c1e162662aa73f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads edges from a file.  <br /></td></tr>
<tr class="separator:a61c210a08b68a8b7c1e162662aa73f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3d353c13d042ac9427d1d3f544d9bc" id="r_afd3d353c13d042ac9427d1d3f544d9bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd3d353c13d042ac9427d1d3f544d9bc">read_vertexes</a> (const string &amp;vertex_file)</td></tr>
<tr class="memdesc:afd3d353c13d042ac9427d1d3f544d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads vertices from a file.  <br /></td></tr>
<tr class="separator:afd3d353c13d042ac9427d1d3f544d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58398663caa62bc7b7648b787083c06c" id="r_a58398663caa62bc7b7648b787083c06c"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58398663caa62bc7b7648b787083c06c">getCurrentEdgesFile</a> () const</td></tr>
<tr class="memdesc:a58398663caa62bc7b7648b787083c06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the current edges file.  <br /></td></tr>
<tr class="separator:a58398663caa62bc7b7648b787083c06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456215e09af33215ebbbbc62e8e0c886" id="r_a456215e09af33215ebbbbc62e8e0c886"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a456215e09af33215ebbbbc62e8e0c886">getCurrentVertexesFile</a> () const</td></tr>
<tr class="memdesc:a456215e09af33215ebbbbc62e8e0c886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the current vertices file.  <br /></td></tr>
<tr class="separator:a456215e09af33215ebbbbc62e8e0c886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ca554df8a2b71750868582a8cd461" id="r_ab33ca554df8a2b71750868582a8cd461"><td class="memItemLeft" align="right" valign="top"><a id="ab33ca554df8a2b71750868582a8cd461" name="ab33ca554df8a2b71750868582a8cd461"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_edges</b> ()</td></tr>
<tr class="memdesc:ab33ca554df8a2b71750868582a8cd461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the edges of the graph. <br /></td></tr>
<tr class="separator:ab33ca554df8a2b71750868582a8cd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276806a7204c5eb3a01e66ca518799af" id="r_a276806a7204c5eb3a01e66ca518799af"><td class="memItemLeft" align="right" valign="top"><a id="a276806a7204c5eb3a01e66ca518799af" name="a276806a7204c5eb3a01e66ca518799af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_vertexes</b> ()</td></tr>
<tr class="memdesc:a276806a7204c5eb3a01e66ca518799af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the vertices of the graph. <br /></td></tr>
<tr class="separator:a276806a7204c5eb3a01e66ca518799af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb3635282ad54bc779ee0cb210d9866" id="r_a4eb3635282ad54bc779ee0cb210d9866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eb3635282ad54bc779ee0cb210d9866">backtracking</a> ()</td></tr>
<tr class="memdesc:a4eb3635282ad54bc779ee0cb210d9866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the backtracking algorithm for the TSP.  <br /></td></tr>
<tr class="separator:a4eb3635282ad54bc779ee0cb210d9866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5f23e1e71bd39b33e809c98bd375b3" id="r_a9a5f23e1e71bd39b33e809c98bd375b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a5f23e1e71bd39b33e809c98bd375b3">recursiveBacktracking</a> (int currentVertexId, bool *visited, vector&lt; int &gt; &amp;currentPath, vector&lt; int &gt; &amp;finalPath, int nVertexes, int uniqueVertexes, double currentCost, double &amp;finalCost)</td></tr>
<tr class="memdesc:a9a5f23e1e71bd39b33e809c98bd375b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively explores all possible paths using backtracking to find the minimum cost Hamiltonian path.  <br /></td></tr>
<tr class="separator:a9a5f23e1e71bd39b33e809c98bd375b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2b8d8be9932342868259db53c7042b" id="r_a3e2b8d8be9932342868259db53c7042b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2b8d8be9932342868259db53c7042b">triangularApproximation</a> ()</td></tr>
<tr class="memdesc:a3e2b8d8be9932342868259db53c7042b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the triangular approximation algorithm to find an approximate solution to the TSP.  <br /></td></tr>
<tr class="separator:a3e2b8d8be9932342868259db53c7042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d4ce342534d737d3e6662a33f4209" id="r_ae38d4ce342534d737d3e6662a33f4209"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae38d4ce342534d737d3e6662a33f4209">getPrimMST</a> (int startingNode=0)</td></tr>
<tr class="memdesc:ae38d4ce342534d737d3e6662a33f4209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Minimum Spanning Tree (MST) using Prim's algorithm.  <br /></td></tr>
<tr class="separator:ae38d4ce342534d737d3e6662a33f4209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c3fc4dcc9dcca01ca015e6f3a586c1" id="r_a90c3fc4dcc9dcca01ca015e6f3a586c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90c3fc4dcc9dcca01ca015e6f3a586c1">getDistance</a> (int v, int w)</td></tr>
<tr class="memdesc:a90c3fc4dcc9dcca01ca015e6f3a586c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance between two vertices.  <br /></td></tr>
<tr class="separator:a90c3fc4dcc9dcca01ca015e6f3a586c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1da3211cc4dca868016a3d47fda91a5" id="r_aa1da3211cc4dca868016a3d47fda91a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1da3211cc4dca868016a3d47fda91a5">preorderWalkMST</a> (const vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;mst, int currentVertex, bool *visited, vector&lt; int &gt; &amp;tour)</td></tr>
<tr class="memdesc:aa1da3211cc4dca868016a3d47fda91a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preorder walk of the MST.  <br /></td></tr>
<tr class="separator:aa1da3211cc4dca868016a3d47fda91a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa825a18d1a69be2b16855a7ab9eb8210" id="r_aa825a18d1a69be2b16855a7ab9eb8210"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa825a18d1a69be2b16855a7ab9eb8210">getMinimumCost</a> (vector&lt; int &gt; path)</td></tr>
<tr class="memdesc:aa825a18d1a69be2b16855a7ab9eb8210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the minimum cost of a given path.  <br /></td></tr>
<tr class="separator:aa825a18d1a69be2b16855a7ab9eb8210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe6dc2b6372ccac2b8a3606917943df" id="r_abbe6dc2b6372ccac2b8a3606917943df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe6dc2b6372ccac2b8a3606917943df">Christofides</a> ()</td></tr>
<tr class="memdesc:abbe6dc2b6372ccac2b8a3606917943df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Christofides algorithm for the TSP.  <br /></td></tr>
<tr class="separator:abbe6dc2b6372ccac2b8a3606917943df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428010a68b516490eaf7af3bbb6db35e" id="r_a428010a68b516490eaf7af3bbb6db35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a428010a68b516490eaf7af3bbb6db35e">perfectMatching</a> (vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;mst, vector&lt; pair&lt; int, int &gt; &gt; &amp;matchingVertexes)</td></tr>
<tr class="memdesc:a428010a68b516490eaf7af3bbb6db35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a perfect matching in the MST.  <br /></td></tr>
<tr class="separator:a428010a68b516490eaf7af3bbb6db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93b5f69ccb59266b7fac2724798ed30" id="r_af93b5f69ccb59266b7fac2724798ed30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af93b5f69ccb59266b7fac2724798ed30">euler_tour</a> (vector&lt; pair&lt; int, int &gt; &gt; &amp;matchingVertexes, vector&lt; int &gt; &amp;path, vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;mst, int startingNode)</td></tr>
<tr class="memdesc:af93b5f69ccb59266b7fac2724798ed30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Euler tour in the graph.  <br /></td></tr>
<tr class="separator:af93b5f69ccb59266b7fac2724798ed30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3167c0ae46b0cf1ace51112756a8b3a" id="r_aa3167c0ae46b0cf1ace51112756a8b3a"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3167c0ae46b0cf1ace51112756a8b3a">make_hamiltonian</a> (vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:aa3167c0ae46b0cf1ace51112756a8b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a Hamiltonian path from a given path.  <br /></td></tr>
<tr class="separator:aa3167c0ae46b0cf1ace51112756a8b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd7845b75d36012e5374484a7712b40" id="r_a1fd7845b75d36012e5374484a7712b40"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd7845b75d36012e5374484a7712b40">createReducedMatrix</a> ()</td></tr>
<tr class="memdesc:a1fd7845b75d36012e5374484a7712b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reduced distance matrix.  <br /></td></tr>
<tr class="separator:a1fd7845b75d36012e5374484a7712b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1ebd89e4c4c27371a3eb2af3ecd28" id="r_a16e1ebd89e4c4c27371a3eb2af3ecd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16e1ebd89e4c4c27371a3eb2af3ecd28">twoOptSearchOptimization</a> (vector&lt; int &gt; &amp;tour, const vector&lt; vector&lt; double &gt; &gt; &amp;distanceMatrix)</td></tr>
<tr class="memdesc:a16e1ebd89e4c4c27371a3eb2af3ecd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes a tour using the 2-opt algorithm.  <br /></td></tr>
<tr class="separator:a16e1ebd89e4c4c27371a3eb2af3ecd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cb7e7a77fd2547280babb0c7eb5947" id="r_a41cb7e7a77fd2547280babb0c7eb5947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41cb7e7a77fd2547280babb0c7eb5947">dfs</a> (int vertex, vector&lt; bool &gt; &amp;visited, vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;mst, vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a41cb7e7a77fd2547280babb0c7eb5947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search (DFS) for the Euler tour.  <br /></td></tr>
<tr class="separator:a41cb7e7a77fd2547280babb0c7eb5947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ed2cafdaabf6f68d7831eba0e02446" id="r_a45ed2cafdaabf6f68d7831eba0e02446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ed2cafdaabf6f68d7831eba0e02446">isCircularPath</a> (vector&lt; int &gt; &amp;path, int startingNode=0)</td></tr>
<tr class="memdesc:a45ed2cafdaabf6f68d7831eba0e02446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given path is circular.  <br /></td></tr>
<tr class="separator:a45ed2cafdaabf6f68d7831eba0e02446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80e31d10e9bdf44e800b7b787deccd" id="r_a1b80e31d10e9bdf44e800b7b787deccd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b80e31d10e9bdf44e800b7b787deccd">isFeasiblePath</a> (int startingNode, const vector&lt; vector&lt; double &gt; &gt; &amp;distanceMatrix)</td></tr>
<tr class="memdesc:a1b80e31d10e9bdf44e800b7b787deccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given path is feasible.  <br /></td></tr>
<tr class="separator:a1b80e31d10e9bdf44e800b7b787deccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c22400cad66599f5d70585ce095dc" id="r_a6f5c22400cad66599f5d70585ce095dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f5c22400cad66599f5d70585ce095dc">calculatePathCostWithoutCoordinates</a> (vector&lt; int &gt; path, double &amp;minimumCost)</td></tr>
<tr class="memdesc:a6f5c22400cad66599f5d70585ce095dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of a path without using coordinates.  <br /></td></tr>
<tr class="separator:a6f5c22400cad66599f5d70585ce095dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a8fe4d545c7df1dba1c92780440825" id="r_a77a8fe4d545c7df1dba1c92780440825"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a8fe4d545c7df1dba1c92780440825">checkDistance</a> (int v, int w)</td></tr>
<tr class="memdesc:a77a8fe4d545c7df1dba1c92780440825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the distance between two vertices.  <br /></td></tr>
<tr class="separator:a77a8fe4d545c7df1dba1c92780440825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd48975365fd8283ddc32d2e50a3bf5e" id="r_afd48975365fd8283ddc32d2e50a3bf5e"><td class="memItemLeft" align="right" valign="top"><a id="afd48975365fd8283ddc32d2e50a3bf5e" name="afd48975365fd8283ddc32d2e50a3bf5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkCurrentFiles</b> ()</td></tr>
<tr class="memdesc:afd48975365fd8283ddc32d2e50a3bf5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the current files being used. <br /></td></tr>
<tr class="separator:afd48975365fd8283ddc32d2e50a3bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a646b1458cebe3fcffb2bc9ecc7ea" id="r_a709a646b1458cebe3fcffb2bc9ecc7ea"><td class="memItemLeft" align="right" valign="top"><a id="a709a646b1458cebe3fcffb2bc9ecc7ea" name="a709a646b1458cebe3fcffb2bc9ecc7ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>runAllAlgorithms</b> ()</td></tr>
<tr class="memdesc:a709a646b1458cebe3fcffb2bc9ecc7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs all algorithms. <br /></td></tr>
<tr class="separator:a709a646b1458cebe3fcffb2bc9ecc7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da4fa8365233c370f7588e143399e3" id="r_a14da4fa8365233c370f7588e143399e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14da4fa8365233c370f7588e143399e3">optimizedTriangularApproximation</a> ()</td></tr>
<tr class="memdesc:a14da4fa8365233c370f7588e143399e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes an optimized triangular approximation algorithm for the Traveling Salesman Problem (TSP).  <br /></td></tr>
<tr class="separator:a14da4fa8365233c370f7588e143399e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8d559a70a6fe05bee140347746f5e2" id="r_a0d8d559a70a6fe05bee140347746f5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d8d559a70a6fe05bee140347746f5e2">createClusters</a> (double dist, vector&lt; vector&lt; double &gt; &gt; distanceMatrix, vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;newAdj, vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &amp;anchors)</td></tr>
<tr class="memdesc:a0d8d559a70a6fe05bee140347746f5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates clusters of vertices based on a distance threshold.  <br /></td></tr>
<tr class="separator:a0d8d559a70a6fe05bee140347746f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662aaddf0424b5206a08e5f1a1067581" id="r_a662aaddf0424b5206a08e5f1a1067581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a662aaddf0424b5206a08e5f1a1067581">preorderWalkOpt</a> (vector&lt; int &gt; &amp;path, bool *visited, <a class="el" href="class_vertex.html">Vertex</a> &amp;start, vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;mstAdj)</td></tr>
<tr class="memdesc:a662aaddf0424b5206a08e5f1a1067581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a pre-order traversal of the Minimum Spanning Tree (MST).  <br /></td></tr>
<tr class="separator:a662aaddf0424b5206a08e5f1a1067581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc3c921519354f9fde81f0e01a84b81c" id="r_abc3c921519354f9fde81f0e01a84b81c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc3c921519354f9fde81f0e01a84b81c">getPrimMSTopt</a> (vector&lt; pair&lt; int, float &gt; &gt; &amp;parent, bool *visited, <a class="el" href="class_vertex.html">Vertex</a> &amp;start, vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;clusterAdj, vector&lt; vector&lt; double &gt; &gt; &amp;distanceMatrix, vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;mstAdj)</td></tr>
<tr class="memdesc:abc3c921519354f9fde81f0e01a84b81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the Minimum Spanning Tree (MST) using an optimized Prim's algorithm.  <br /></td></tr>
<tr class="separator:abc3c921519354f9fde81f0e01a84b81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a graph. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa58172b1ae8602834b045659efd29c8" name="aaa58172b1ae8602834b045659efd29c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa58172b1ae8602834b045659efd29c8">&#9670;&#160;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_file</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertex_file</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="class_graph.html" title="Class representing a graph.">Graph</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_file</td><td>Name of the file containing the edges. </td></tr>
    <tr><td class="paramname">vertex_file</td><td>Name of the file containing the vertices (optional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4eb3635282ad54bc779ee0cb210d9866" name="a4eb3635282ad54bc779ee0cb210d9866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb3635282ad54bc779ee0cb210d9866">&#9670;&#160;</a></span>backtracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::backtracking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the backtracking algorithm for the TSP. </p>
<p>O(N!) where N is the number of vertices.</p>
<p>This function applies the backtracking algorithm to find the minimum cost Hamiltonian path in the graph. It starts from the initial vertex and explores all possible paths recursively, keeping track of the visited vertices and current path cost. Once all paths are explored, it selects the path with the minimum cost as the final solution. </p><dl class="section note"><dt>Note</dt><dd>If the number of vertices exceeds 20, the function prints a message indicating that the execution is not reasonable due to computational complexity. </dd></dl>

</div>
</div>
<a id="a6f5c22400cad66599f5d70585ce095dc" name="a6f5c22400cad66599f5d70585ce095dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5c22400cad66599f5d70585ce095dc">&#9670;&#160;</a></span>calculatePathCostWithoutCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::calculatePathCostWithoutCoordinates </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>minimumCost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cost of a path without using coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector representing the path. </td></tr>
    <tr><td class="paramname">minimumCost</td><td>Reference to the variable storing the minimum cost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false otherwise.</dd></dl>
<p>O(N) where N is the number of vertices in the path. </p>

</div>
</div>
<a id="a77a8fe4d545c7df1dba1c92780440825" name="a77a8fe4d545c7df1dba1c92780440825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a8fe4d545c7df1dba1c92780440825">&#9670;&#160;</a></span>checkDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::checkDistance </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the distance between two vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>ID of the first vertex. </td></tr>
    <tr><td class="paramname">w</td><td>ID of the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the vertices.</dd></dl>
<p>O(N) where N is the number of vertices. </p>

</div>
</div>
<a id="abbe6dc2b6372ccac2b8a3606917943df" name="abbe6dc2b6372ccac2b8a3606917943df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe6dc2b6372ccac2b8a3606917943df">&#9670;&#160;</a></span>Christofides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::Christofides </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Christofides algorithm for the TSP. </p>
<p>O(N^3) where N is the number of vertices.</p>
<p>This function implements the Christofides algorithm for solving the TSP, which provides a solution that is at most 1.5 times the optimal solution. It involves the following steps:</p><ol type="1">
<li>Prompts the user to select a starting node.</li>
<li>Constructs a Minimum Spanning Tree (MST) starting from the selected node.</li>
<li>Finds a perfect matching for the MST.</li>
<li>Combines the MST and the perfect matching to form an Eulerian tour.</li>
<li>Converts the Eulerian tour into a Hamiltonian path by removing repeated nodes.</li>
<li>Optimizes the Hamiltonian path using the 2-opt algorithm.</li>
<li>Validates and calculates the cost of the final TSP path.</li>
<li>Outputs the path, the minimum cost, and the execution time. </li>
</ol>

</div>
</div>
<a id="a0d8d559a70a6fe05bee140347746f5e2" name="a0d8d559a70a6fe05bee140347746f5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8d559a70a6fe05bee140347746f5e2">&#9670;&#160;</a></span>createClusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::createClusters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dist</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>distanceMatrix</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newAdj</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>anchors</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates clusters of vertices based on a distance threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>Distance threshold for clustering. </td></tr>
    <tr><td class="paramname">distanceMatrix</td><td>Vector of vectors of doubles representing the distance matrix between vertices. </td></tr>
    <tr><td class="paramname">newAdj</td><td>Vector of vectors of vertices representing the new adjacency list of the new clusters. </td></tr>
    <tr><td class="paramname">anchors</td><td>Vector of vertices that will act as cluster anchors.</td></tr>
  </table>
  </dd>
</dl>
<p>O(V^2) where V is the number of vertices.</p>
<p>This function iterates through all vertices, assigning each vertex to an anchor if the distance is below the threshold. If a vertex cannot be assigned to any existing anchor, it becomes a new anchor. Each cluster is stored in the <code>clusters</code> vector, and the adjacency list for the new clusters is updated accordingly. </p>

</div>
</div>
<a id="a1fd7845b75d36012e5374484a7712b40" name="a1fd7845b75d36012e5374484a7712b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd7845b75d36012e5374484a7712b40">&#9670;&#160;</a></span>createReducedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; Graph::createReducedMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a reduced distance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors of doubles representing the reduced distance matrix.</dd></dl>
<p>O(N^2) where N is the number of vertices. </p>

</div>
</div>
<a id="a41cb7e7a77fd2547280babb0c7eb5947" name="a41cb7e7a77fd2547280babb0c7eb5947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cb7e7a77fd2547280babb0c7eb5947">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfs </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>vertex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>visited</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth-First Search (DFS) for the Euler tour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Current vertex in the DFS. </td></tr>
    <tr><td class="paramname">visited</td><td>Vector indicating visited vertices. </td></tr>
    <tr><td class="paramname">mst</td><td>Vector of vectors of edges representing the MST. </td></tr>
    <tr><td class="paramname">path</td><td>Vector representing the path.</td></tr>
  </table>
  </dd>
</dl>
<p>O(V + E) where V is the number of vertices and E is the number of edges. </p>

</div>
</div>
<a id="af93b5f69ccb59266b7fac2724798ed30" name="af93b5f69ccb59266b7fac2724798ed30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93b5f69ccb59266b7fac2724798ed30">&#9670;&#160;</a></span>euler_tour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::euler_tour </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matchingVertexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startingNode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an Euler tour in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matchingVertexes</td><td>Vector of pairs representing the matching vertices. </td></tr>
    <tr><td class="paramname">path</td><td>Vector representing the path. </td></tr>
    <tr><td class="paramname">mst</td><td>Vector of vectors of edges representing the MST. </td></tr>
    <tr><td class="paramname">startingNode</td><td>Starting node for the Euler tour.</td></tr>
  </table>
  </dd>
</dl>
<p>O(V + E) where V is the number of vertices and E is the number of edges. </p>

</div>
</div>
<a id="a58398663caa62bc7b7648b787083c06c" name="a58398663caa62bc7b7648b787083c06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58398663caa62bc7b7648b787083c06c">&#9670;&#160;</a></span>getCurrentEdgesFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Graph::getCurrentEdgesFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the current edges file. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the string containing the name of the edges file. </dd></dl>

</div>
</div>
<a id="a456215e09af33215ebbbbc62e8e0c886" name="a456215e09af33215ebbbbc62e8e0c886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456215e09af33215ebbbbc62e8e0c886">&#9670;&#160;</a></span>getCurrentVertexesFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Graph::getCurrentVertexesFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the current vertices file. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the string containing the name of the vertices file. </dd></dl>

</div>
</div>
<a id="a90c3fc4dcc9dcca01ca015e6f3a586c1" name="a90c3fc4dcc9dcca01ca015e6f3a586c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c3fc4dcc9dcca01ca015e6f3a586c1">&#9670;&#160;</a></span>getDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getDistance </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the distance between two vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>id of the first vertex. </td></tr>
    <tr><td class="paramname">w</td><td>id of the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the vertices. </dd></dl>

</div>
</div>
<a id="aa825a18d1a69be2b16855a7ab9eb8210" name="aa825a18d1a69be2b16855a7ab9eb8210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa825a18d1a69be2b16855a7ab9eb8210">&#9670;&#160;</a></span>getMinimumCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getMinimumCost </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the minimum cost of a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum cost of the path.</dd></dl>
<p>O(N) where N is the number of vertices in the path. </p>

</div>
</div>
<a id="ae38d4ce342534d737d3e6662a33f4209" name="ae38d4ce342534d737d3e6662a33f4209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38d4ce342534d737d3e6662a33f4209">&#9670;&#160;</a></span>getPrimMST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; Graph::getPrimMST </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startingNode</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Minimum Spanning Tree (MST) using Prim's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingNode</td><td>Starting node for Prim's algorithm (default is 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of vectors of edges representing the MST.</dd></dl>
<p>O((V + E) log V) where V is the number of vertices and E is the number of edges.</p>
<p>This function constructs a Minimum Spanning Tree (MST) using Prim's algorithm starting from the specified node. It returns the MST represented as a vector of vectors of Edges, where each inner vector contains the edges incident to a vertex in the MST. </p>

</div>
</div>
<a id="abc3c921519354f9fde81f0e01a84b81c" name="abc3c921519354f9fde81f0e01a84b81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3c921519354f9fde81f0e01a84b81c">&#9670;&#160;</a></span>getPrimMSTopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::getPrimMSTopt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, float &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>visited</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clusterAdj</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>distanceMatrix</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mstAdj</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the Minimum Spanning Tree (MST) using an optimized Prim's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Vector of pairs where each pair contains the parent vertex ID and the edge weight to the child vertex. </td></tr>
    <tr><td class="paramname">visited</td><td>Array of booleans indicating whether each vertex has been visited. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex for Prim's algorithm. </td></tr>
    <tr><td class="paramname">clusterAdj</td><td>Vector of vectors of vertices representing the adjacency list of the clusters. </td></tr>
    <tr><td class="paramname">distanceMatrix</td><td>Vector of vectors of doubles representing the distance matrix between vertices. </td></tr>
    <tr><td class="paramname">mstAdj</td><td>Vector of vectors of vertices representing the MST adjacency list.</td></tr>
  </table>
  </dd>
</dl>
<p>O(E log V) where E is the number of edges and V is the number of vertices.</p>
<p>This function uses a priority queue to efficiently find the next vertex to add to the MST. Each vertex is connected to its parent with the minimum edge weight, and the adjacency list for the MST is updated accordingly. The <code>visited</code> array ensures that each vertex is only processed once. </p>

</div>
</div>
<a id="a45ed2cafdaabf6f68d7831eba0e02446" name="a45ed2cafdaabf6f68d7831eba0e02446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ed2cafdaabf6f68d7831eba0e02446">&#9670;&#160;</a></span>isCircularPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isCircularPath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startingNode</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given path is circular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector representing the path. </td></tr>
    <tr><td class="paramname">startingNode</td><td>Starting node for the path (default is 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path is circular, false otherwise.</dd></dl>
<p>O(N) where N is the number of vertices in the path. </p>

</div>
</div>
<a id="a1b80e31d10e9bdf44e800b7b787deccd" name="a1b80e31d10e9bdf44e800b7b787deccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b80e31d10e9bdf44e800b7b787deccd">&#9670;&#160;</a></span>isFeasiblePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isFeasiblePath </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startingNode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>distanceMatrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given path is feasible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startingNode</td><td>The node from which to start the BFS. </td></tr>
    <tr><td class="paramname">distanceMatrix</td><td>A matrix representing the distances between vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path is feasible, false otherwise.</dd></dl>
<p>O(N^2) where N is the number of vertices. @detailsThis function performs a Breadth-First Search (BFS) to determine if all vertices in the graph are reachable from the specified starting node, thus checking if a feasible path exists that visits all vertices. </p>

</div>
</div>
<a id="aa3167c0ae46b0cf1ace51112756a8b3a" name="aa3167c0ae46b0cf1ace51112756a8b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3167c0ae46b0cf1ace51112756a8b3a">&#9670;&#160;</a></span>make_hamiltonian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::make_hamiltonian </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a Hamiltonian path from a given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector representing the Hamiltonian path.</dd></dl>
<p>O(N) where N is the number of vertices in the path. </p>

</div>
</div>
<a id="a14da4fa8365233c370f7588e143399e3" name="a14da4fa8365233c370f7588e143399e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da4fa8365233c370f7588e143399e3">&#9670;&#160;</a></span>optimizedTriangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::optimizedTriangularApproximation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes an optimized triangular approximation algorithm for the Traveling Salesman Problem (TSP). </p>
<p>This function creates a distance matrix, clusters vertices based on average edge distance, and uses Prim's algorithm to construct a Minimum Spanning Tree (MST) for each cluster. It then performs a pre-order traversal of the MST to generate an approximate solution for the TSP. The path and the associated cost are outputted.</p>
<p>The complexity is approximately O(V^2) due to the distance matrix creation and MST construction. </p>

</div>
</div>
<a id="a428010a68b516490eaf7af3bbb6db35e" name="a428010a68b516490eaf7af3bbb6db35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428010a68b516490eaf7af3bbb6db35e">&#9670;&#160;</a></span>perfectMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::perfectMatching </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matchingVertexes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a perfect matching in the MST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>Vector of vectors of edges representing the MST. </td></tr>
    <tr><td class="paramname">matchingVertexes</td><td>Vector of pairs representing the matching vertices.</td></tr>
  </table>
  </dd>
</dl>
<p>O(N^2) where N is the number of vertices.</p>
<p>This function identifies all vertices in the MST that have an odd degree and finds a perfect matching for them. It does this by pairing each unvisited odd vertex with its closest unvisited neighbor. </p>

</div>
</div>
<a id="aa1da3211cc4dca868016a3d47fda91a5" name="aa1da3211cc4dca868016a3d47fda91a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1da3211cc4dca868016a3d47fda91a5">&#9670;&#160;</a></span>preorderWalkMST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preorderWalkMST </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="class_edge.html">Edge</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>currentVertex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>visited</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tour</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preorder walk of the MST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>Vector of vectors of edges representing the MST. </td></tr>
    <tr><td class="paramname">currentVertex</td><td>Current vertex in the walk. </td></tr>
    <tr><td class="paramname">visited</td><td>Array indicating visited vertices. </td></tr>
    <tr><td class="paramname">tour</td><td>Vector representing the tour.</td></tr>
  </table>
  </dd>
</dl>
<p>O(N) where N is the number of vertices. </p>

</div>
</div>
<a id="a662aaddf0424b5206a08e5f1a1067581" name="a662aaddf0424b5206a08e5f1a1067581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662aaddf0424b5206a08e5f1a1067581">&#9670;&#160;</a></span>preorderWalkOpt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::preorderWalkOpt </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>visited</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="class_vertex.html">Vertex</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mstAdj</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a pre-order traversal of the Minimum Spanning Tree (MST). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector of integers where each integer represents the ID of a vertex in the traversal path. </td></tr>
    <tr><td class="paramname">visited</td><td>Array of booleans indicating whether each vertex has been visited. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex for the pre-order traversal. </td></tr>
    <tr><td class="paramname">mstAdj</td><td>Vector of vectors of vertices representing the adjacency list of the MST.</td></tr>
  </table>
  </dd>
</dl>
<p>O(N) where N is the number of vertices.</p>
<p>This function recursively visits each vertex in a pre-order manner, starting from the given start vertex. It marks each visited vertex and adds it to the traversal path. The traversal continues to all adjacent vertices that have not been visited yet. </p>

</div>
</div>
<a id="a61c210a08b68a8b7c1e162662aa73f50" name="a61c210a08b68a8b7c1e162662aa73f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c210a08b68a8b7c1e162662aa73f50">&#9670;&#160;</a></span>read_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::read_edges </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_file</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>comesWithNodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads edges from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_file</td><td>Name of the file containing the edges. </td></tr>
    <tr><td class="paramname">comesWithNodes</td><td>Boolean indicating if the file contains node information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure.</dd></dl>
<p>O(|E|) where |E| is the number of edges in the file. </p>

</div>
</div>
<a id="afd3d353c13d042ac9427d1d3f544d9bc" name="afd3d353c13d042ac9427d1d3f544d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3d353c13d042ac9427d1d3f544d9bc">&#9670;&#160;</a></span>read_vertexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::read_vertexes </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertex_file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads vertices from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_file</td><td>Name of the file containing the vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 on failure.</dd></dl>
<p>O(|V|) where |V| is the number of vertices in the file. </p>

</div>
</div>
<a id="a9a5f23e1e71bd39b33e809c98bd375b3" name="a9a5f23e1e71bd39b33e809c98bd375b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5f23e1e71bd39b33e809c98bd375b3">&#9670;&#160;</a></span>recursiveBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::recursiveBacktracking </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>currentVertexId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>visited</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>currentPath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>finalPath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nVertexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>uniqueVertexes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>currentCost</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>finalCost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively explores all possible paths using backtracking to find the minimum cost Hamiltonian path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentVertexId</td><td>ID of the current vertex. </td></tr>
    <tr><td class="paramname">visited</td><td>Array indicating visited vertices. </td></tr>
    <tr><td class="paramname">currentPath</td><td>Current path taken. </td></tr>
    <tr><td class="paramname">finalPath</td><td>Final path found. </td></tr>
    <tr><td class="paramname">nVertexes</td><td>Number of vertices. </td></tr>
    <tr><td class="paramname">uniqueVertexes</td><td>Number of unique vertices visited. </td></tr>
    <tr><td class="paramname">currentCost</td><td>Current cost of the path. </td></tr>
    <tr><td class="paramname">finalCost</td><td>Final cost of the path.</td></tr>
  </table>
  </dd>
</dl>
<p>O(N!) where N is the number of vertices.</p>
<p>This function is called recursively to explore all possible paths starting from a given vertex. It marks each visited vertex and updates the current path and cost accordingly. If a Hamiltonian path with a lower cost than the current minimum is found, it updates the final path and cost accordingly. </p>

</div>
</div>
<a id="a3e2b8d8be9932342868259db53c7042b" name="a3e2b8d8be9932342868259db53c7042b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2b8d8be9932342868259db53c7042b">&#9670;&#160;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::triangularApproximation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the triangular approximation algorithm to find an approximate solution to the TSP. </p>
<p>O(N^2) where N is the number of vertices.</p>
<p>This function constructs a Minimum Spanning Tree (MST) using Prim's algorithm and performs a preorder walk on the MST to generate a tour. The resulting tour is an approximate solution to the Traveling Salesman Problem (TSP). </p>

</div>
</div>
<a id="a16e1ebd89e4c4c27371a3eb2af3ecd28" name="a16e1ebd89e4c4c27371a3eb2af3ecd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e1ebd89e4c4c27371a3eb2af3ecd28">&#9670;&#160;</a></span>twoOptSearchOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::twoOptSearchOptimization </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tour</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>distanceMatrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizes a tour using the 2-opt algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tour</td><td>Vector representing the tour. </td></tr>
    <tr><td class="paramname">distanceMatrix</td><td>Vector of vectors of doubles representing the distance matrix. @complexity O(N^2) where N is the number of vertices.</td></tr>
  </table>
  </dd>
</dl>
<p>This function applies the 2-opt optimization technique to improve the given tour by iteratively reversing segments of the tour that reduce the total distance. The process continues until no further improvements can be made. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Asus/Desktop/ProjectDA2/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>C:/Users/Asus/Desktop/ProjectDA2/<b>Graph.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
